\documentclass{llncs}

\usepackage{llncsdoc}

%% PDFLaTeX
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{textcomp}      % for Â° symbol
\usepackage{multirow}
\usepackage{caption}
\usepackage{url}
\usepackage{tabularx}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usepackage{framed}

%% XeLaTeX
% \usepackage{fontspec}
% \usepackage{xunicode}
% \usepackage{xltxtra}

\usepackage{expex}

%
\begin{document}
%
\title{Semantic tagging using HFST}
%
\author{N.N. and N.N.}

 \institute{xx\\
 yy\\
 zz\\
 ww\\
 \email{\{n.n., n.n.\}@xxx.yy}}

\maketitle

% Removed the manual bibstyle in favor of splncs03.bst,
% if it's required fetch it from svn history

\begin{abstract}
%Krister
\end{abstract}

\section*{Introduction}
% Krister (1 p.)

\section{Tokenization using {\tt hfst-pmatch}}\label{sec:tokenization}
% Sam (4 p.)
Tokenization is a necessary first step in most text-based NLP tasks. For some
languages (eg. English) it is often considered to be a mechanical
preprocessing task without linguistic importance, and for others (eg. Chinese)
it is a subtle task given a different name (``segmentation'').

However, even in languages that generally insert spaces between words, there
are issues that influence the quality or feasibility of tools down the
pipeline. We may, for example, want to be able to identify multiword units,
identify compound words and mark their internal boundaries, control various
dimensions of normalisation, or produce possible part-of-speech tags or
deeper morphological analyses.

We describe a general approach to these issues based on morphological
transducers, regular expressions and the pattern matching operation
\verb+pmatch+~\cite{pmatchcite}.

\subsection{Tokenizing with a Dictionary}

\subsubsection{Preserving the Parts of a Multiword Unit}

\subsection{Tokenization Rules as an OOV Fallback}

\subsection{Analysis Cohorts}

\subsection{Chunking}

\subsection{Incorporating other Linguistic Resources}

\section{Morphological Tagging using {\tt hfst-finnpos}}\label{sec:morph-tagging}
% Miikka (4 p.)

Finnpos \cite{silfverberg2015} is a morphological tagger toolkit based
on the Conditional Random Field framework. It is especially geared
toward morphologically rich languages.  It utilizes several
optimizations to ensure fast estimation and inference even with large
label sets. Additionally, it uses sub label dependencies in
unstructured and structured features for counteracting data sparsity
and modeling grammatical phenomena such as case and number congruence.

Besides optimizations and sub-label dependencies
\cite{silfverberg2014}, Finnpos also provides a flexible way of
integrating a morphological analyzer in the tagging
process. Morphological analyses can be use both as features during
estimation and inference and for constraining the set of possible
morphological labels for word forms. Additionally, the analyzer is
used in lemmatization.

For words not recognized by the morphological analyzer, Finnpos
includes a data driven lemmatizer which is based on the averaged
perceptron classifier..

\section{Semantic Tagging using {\tt hfst-pmatch}}\label{sec:sem-tagging}
% Sam (4 p.)

\section{Distortion Filtering with Weighted Regular Expressions}
% Sam & Miikka (3 p.)

\section{Background}\label{sec:background}
% Erik (2 p.)
During the past two years, there have been many improvements to the HFST interface.
We now have a native lexc compiler and the possibility to use hyperminimize the lexc
lexicons. There have also been many bugfixes and improvements to the native XFST compiler.
Flag diacritics are fully supported in all HFST command line tools

We have a download page (http://hfst.sourceforge.net/downloads/). For Linux users, we recommend
a Debian installation which is offered via Apertium. There are instructions and links to Apertium web pages.
For Mac and Windows users, we offer binaries for eight tools:
hfst-xfst, hfst-lexc, hfst-pmatch, hfst-pmatch2fst, hfst-twolc, hfst-proc, hfst-lookup and hfst-optimized-lookup.
There is also a separate MacPorts installation available.

We have tentatively added Xerox's xfsm library as one implementation to HFST.
The preliminary results for minimization and composition implementations for an unweighted OMorFi intermediate transducer
with ca 250 000 states and 600 000 transitions are as follows (in composition the transducer was composed with itself):
            
         minimization composition
xfsm      0,74 s       0,49 s
foma      0,53 s       2,00 s
openfst   5,09 s       2,34 s
sfst      1,32 s       1,78 s

The slowness of openfst is possibly due to the old version that we have as our back-end and maybe
because openfst handles weighted transducers. 
In xfsm composition, unknown and identity symbols are handled as a part of the composition itself,
but for other back-ends some post- and preprocessing is needed. This might explain why they are slower in composition.

\section{Discussion and Conclusion}\label{sec:discussion}
% Krister (1 p.)

\bibliographystyle{splncs03}
\bibliography{sfcm-2015}

\end{document}
% vim: set spell:
