% This is the Authors' notes demonstration file with content stripped out
% and sections from Krister's email substituted.
% 
% It might be a good idea to verify that Authors' Instructions.pdf
% (in this directory) is adhered to before submitting.
%
% llncs.doc is actually a tex file, it's the source for the Authors'
% Instructions. There are good examples of eg. tables and graphs there.
\documentclass{llncs}
\usepackage{llncsdoc}
\usepackage{multirow}
\usepackage{caption}
%
\begin{document}
%
\title{HFST - Framework for Compiling and Applying Morphologies}
%
\author{Author Names\inst{}}

\institute{University of Helsinki}

\maketitle
%
% Modify the bibliography environment to call for the author-year
% system. This is done normally with the citeauthoryear option
% for a particular contribution.

% SH: Not sure we need this ... the example file had two articles, the latter with this format.
% It should be possible to comment out until the abstract and get the 'regular' citation.
\makeatletter
\renewenvironment{thebibliography}[1]
     {\section*{\refname}
      \small
      \list{}%
           {\settowidth\labelwidth{}%
            \leftmargin\parindent
            \itemindent=-\parindent
            \labelsep=\z@
            \if@openbib
              \advance\leftmargin\bibindent
              \itemindent -\bibindent
              \listparindent \itemindent
              \parsep \z@
            \fi
            \usecounter{enumiv}%
            \let\p@enumiv\@empty
            \renewcommand\theenumiv{}}%
      \if@openbib
        \renewcommand\newblock{\par}%
      \else
        \renewcommand\newblock{\hskip .11em \@plus.33em \@minus.07em}%
      \fi
      \sloppy\clubpenalty4000\widowpenalty4000%
      \sfcode`\.=\@m}
     {\def\@noitemerr
       {\@latex@warning{Empty `thebibliography' environment}}%
      \endlist}
      \def\@cite#1{#1}%
      \def\@lbibitem[#1]#2{\item[]\if@filesw
        {\def\protect##1{\string ##1\space}\immediate
      \write\@auxout{\string\bibcite{#2}{#1}}}\fi\ignorespaces}
\makeatother
%
\begin{abstract}
% KL
\keywords{finite-state morphology}
\end{abstract}

\section*{Introduction}
% KL


\section{Structural Layout}
% MS


\section{Structural Layout cont.}
% SH
% Comment to remove before submission:
% the relatively insignificant material here should really be incorporated into
% another section..
There has been considerable progress in achieving HSFT's goal of acting as a
compatibility layer between different representations of finite-state
transducers and, more importantly, the operations and formalisms (eg.
\verb+lexc/twolc+, \verb+xfst+, \verb+sfst+) that have been implemented
for them. HFST is now independent of any particular library and requires no
custom extensions to the libraries it uses.

\subsection{Dynamic Linking to Underlying Libraries}
Previously HFST relied on custom extensions to the libraries it supported,
namely OpenFst and SFST, and it was necessary to statically link them into
\verb+libhfst+. This was obviously also rather restrictive in terms of
new versions and different use cases (eg. experimentation with local changes to
the underlying libraries.

HFST3 supports conditional compilation of all its elements that provide
interfaces to underlying libraries, and dynamic linking is done to whichever
libraries the user configures HFST3 to use.

\subsection{Stand-alone Use and Flexibility}
Due to these improvements, HFST3 can also be built without any external
libraries (in which case only the operations for a simple internal
representation and optimized-lookup (see section \ref{optimized-lookup}),
building from text representation and fast lookup will be supported) or only
the user's self-made library, which will then support compilation to
optimized-lookup format.

\section{Coding Priciples}
% EA

Exceptional situations occur sometimes in computer programs when the
user does something wrong or there is a bug in the code.
Possible user-originating situations in a finite-state library could
be for example:

\begin{enumerate} 
\item The user tries to read a binary transducer from a
file that contains a text document or does not exist.
\item A transducer in AT \& T text format has a typo on one line and the 
line cannot be parsed. 
\item The user calls a function without checking the preconditions,
e.g. tries to extract all paths from a cyclic transducer.
\end{enumerate}

Throwing an exception on such occasions gives the user a possibility
to catch the exception and recover from the situation. In HFST version
2.0, exceptional situations were handled by printing to standard error
a short message and exiting with an error code. In HFST version 3, 
exceptions are classes that have a figurative name and can contain an 
error message.

For the above scenarios, HFST will throw the following exceptions:

\begin{enumerate} 
\item NotTransducerStreamException or StreamCannotBeReadException and
the name of the file or stream in the error message.
\item NotValidAttFormatException and the line that could not be parsed
in the error message.
\item TransducerIsCyclicException.
\end{enumerate} 

The user could react to the exceptions in the following ways, for
example:

\begin{enumerate} 
\item Check that the file exists and contains transducers and try again
with the correct file.
\item Fix the typo in the text format.
\item Call another function that limits the number of paths extracted
from the transducer.
\end{enumerate} 

Exceptions are also used internally in HFST code for reporting to the 
calling function that something unexpected happened. The calling
function can handle the situation or inform the user of it. 
So the execution of the program does not need to stop or lead to an
erraneous result or even cause later a segmentation fault.

An HfstFatalException is thrown when it is supposed that the user
cannot handle that exception. The user should instead report the error
to the developers of HFST and in which circumstances it happened, because that
is essentially a bug that must be fixed. Sometimes asserts are also
used for internal checks. When an assertion fails the user should similarly
report the assert message and from which file and which line it happened.


\section{Data Format}
% EA

\subsection{Transducer binary format}

An HFST transducer in binary format consists of an HFST header followed by the
backend implementation in binary format. In version 3.0, the header
format is less error-prone than in the previous version and gives more 
information both for users of HFST (even when seen on a screen or in a
text editor in binary format) and for the HFST library itself.
 
The current header format is somewhat similar to foma where pieces of 
information are separated by newline characters to make them more
readable. In HFST version 2, we represented the properties of a
transducer in a cryptic two-byte bit vector akin to OpenFst's header
format. The type of the transducer and the existence of an optional
alphabet were also encoded with two characters in the beginning of the
binary transducer and they were impossible to interpret without
looking at the HFST code itself.

The beginning of an HFST version 3.0 header contains an identifier
'HFST', a separating zero byte, two bytes signifying the length of
the rest of the header in bytes and a separating zero byte. The rest
of the header contains pairs of attributes and their values. The pairs
are separated by newlines and attributes and values by zero bytes. 
HFST version 3.0 header must contain at least the attributes
'version', 'type' and 'name' (in that order) and their values. 
Additional attributes can follow after these obligatory ones. 
For instance, we could include information on the minimality or
cyclicity of a transducer even if the backend implementation did not
store these properties in its binary format (e.g. SFST). 
For more information on the header format, see (ref. to HfstTransducerHeader).

The new header format makes it easier to react to unexpected
situations and inform the user of them. When we start to read an HFST
binary transducer, we first see whether the identifier 'HFST' is
found. If it is not found, we know that the user has given a wrong
type of file and can throw a appropriate exception. 
Next we see what kind of transducer is coming from the stream. 
If the backend transducer library is not linked to HFST, we can handle
the situation by throwing an exception again. 
Next we see the HFST version used and know how to process the header
and the backend implementation correctly. 
If the user has requested a verbose mode for a tool that reads the
transducer, it is possible to print the name of each transducer 
before or after reading it.

\subsection{Conversion between different backend formats}

In HFST version 3.0, the conversion between different backend formats 
(SFST, foma, OpenFst with tropical and logarithmic semiring) is
carried out through HFST's own transducer format, HfstTransitionGraph, 
a simple transition graph datatype that consists of states (unsigned
integers) and transitions between those states.
 
We have chosen to implement HfstTransitionGraph for two
reasons. Firstly, it serves as an intermediate transducer format in
conversions, thus reducing the number of conversion functions from 2 x
N to N x (N - 1), where N is the number of different transducer
backend formats. Secondly, it is easy to implement functions for 
HfstTransitionGraph that allow the user to construct transducers from 
scratch and iterate through their states and transitions. Implementing
such features for some transducer libraries (e.g. SFST and foma) can
be difficult because they are designed to be used on a higher level of 
abstraction. Accordingly, the functions that operate on states and 
transitions are often declared protected and not necessarily well
documented.

HfstTransitionGraph is a class template with template parameters T and
W. T defines the type of transition data that a transition uses and W
the weight type that is used in transitions and final states. 
HfstTransitionGraph contains two maps. One maps each state to a set of
that state's transitions (that are of type class HfstTransition\textless class
T\textgreater). The other maps each final state to its final weight 
(that is of type class W). Class T must use the weight type W. 
A state's transition (class HfstTransition\textless class T\textgreater) 
contains a target state and a transition data field (that is of type class T).

Actually, HfstTransitionGraph is not a transducer but a more
generalized transition graph that can contain many kinds of data in
its transitions. Currently, the HFST library offers the specializations 
HfstBasicTransducer and HfstBasicTransition for HfstTransitionGraph
and HfstTransition. These specializations are designed for weighted 
transducers. The weight class W is a float and the transition data
class T contains an input string, an output string and a weight of
type float. The specializations HfstBasicTransducer and
HfstBasicTransition are used when converting between different
transducer backend formats.

The class template HfstTransitionGraph is designed so that it can
easily be extended for different kinds of transition datatypes. For
example, if HFST tools are used in text-to-speech or speech-to-text
conversion, the symbol type of transitions will probably be something
else than strings.



\section{Alphabet}
% EA

The alphabet of a transducer means all symbols (strings) that are
known to that transducer. The alphabet includes all symbols that occur 
or have occurred in a transition of the transducer unless explicitly
removed from the alphabet. 
If we apply a binary operation (e.g. disjunction or composition) on 
transducers A and B, the resulting transducer's alphabet will include
all symbols that were in the alphabets of A and B. 

In HFST version 2.0, we were not especially interested in alphabets 
since the interface did not offer any way for the user to access a 
transducer's alphabet. It was up to the backend implementation to take
care of alphabets. In SFST the transducers always have an alphabet,
but in OpenFst their use is optional so we did not use them in our
OpenFst implementation.

In HFST version 3.0, we need to be aware of alphabets because two new
special symbols are included, UNKNOWN and IDENTITY. These special
symbols are a part of the Xerox Finite-State Tool (XFST) formalism 
(Beesley et Karttunen, 2003, page x) and they are also implemented in
foma (Huldén, 2009, page 278). UNKNOWN and IDENTITY symbols are useful
when we want to refer to all symbols that are not currently known to a
transducer but which the transducer can later become aware of. 

Supporting UNKNOWN and IDENTITY symbols in all HFST backend
implementations has enabled us to make an XFST compiler that can be used
with all backend implementations. 
In this way we can offer the users of HFST new regular expression
formalism in addition to the SFST programming language. Next we
describe what these new special symbols require for HFST's
part. Because they are already implemented in foma, we have to care
only for the SFST and OpenFst implementations.

Besides keeping track of all symbols known to a transducer, we also
have to expand each transition involving UNKNOWN and IDENTITY symbols
into a set of transitions every time we apply a binary operation on
two transducers. 
This is because the transducer becomes aware of new symbols that are
no longer unknown and thus no more included in UNKNOWN or IDENTITY
symbols.
Fortunately, this expansion can be done before the operation itself 
(and for composition before and after the operation itself), so we do
not have to make changes in the operations of the backend transducer
libraries. 
The operations can freely (and will) handle these special symbols just
like any ordinary symbols. 

First we iterate through the alphabets of both transducers and find
out what symbols in the alphabet of one transducer are not found in
the alphabet of the other transducer and vice versa. 
Then we add beside each transition involving UNKNOWN or IDENTITY
symbols a set of transitions where UNKNOWN and IDENTITY symbols are
replaced with all symbols that the transducer just got aware of. 
For more information on expanding special symbols, see 
(Huldén, 2009, page 278) and (Beesley et Karttunen, 2003, page x).

It is also possible to switch off special symbol handling if we know
for sure that they are not used in transducers. 
In this way we can optimize performance for instance for the tool 
hfst-calculate that processes SFST programming language which does not
support unknown or identity symbols.


\section{Algorithmic Improvements}
% MS

\section{Xerox Compatibility}
% TP

\section{Compilation Performance}
% EA

The performance of HFST has improved from version 2.0 to 3.0. 
We compiled two finite-state morphologies in SFST programming language format
with HFST versions 2.0 and 3.0. 
The morphologies were OMorFi (ref.) for Finnish and Morphisto (ref.) for German.
In table~\ref{tab:compilation_times} are the compilation times 
for both morphologies with 
different backend implementations with both versions of HFST. 
Note that the foma implementation was not available in version 2.0.

\begin{table}
\centering
  \begin{tabular}{ c | c | c | c }
  \multicolumn{4}{c}{Compilation times} \\ \hline
  Backend & version & Finnish & German \\ \hline
  \multirow{2}{*}{SFST} & 2.0 & 25:16 & 107:47 \\
  & 3.0 & 5:02 & 6:39 \\ \hline
  \multirow{2}{*}{OpenFst} & 2.0 & 7:54 & 6:23 \\
  & 3.0 & 6:51 & 6:28 \\ \hline
  \multirow{2}{*}{foma} & 2.0 & - & - \\
  & 3.0 & 1:49 & 1:29 \\
  \end{tabular}
  \caption{Compilation times for Finnish and German morphologies with
    HFST. The times are expressed in minutes and seconds.}
  \label{tab:compilation_times}
\end{table}

We can clearly see that the compilation time has improved dramatically
for the SFST implementation.
This is mainly because the new version of SFST, 1.4.2, uses Hopcroft's 
minimization algorithm instead of Brzozowski's. 
We noticed how the minimization algorithm affects performance
already when we were testing HFST version 2.0; 
OpenFst was clearly faster because it uses Hopcroft's algorithm. 
Based on this observation, Helmut Schmid could improve his SFST by 
writing a minimization function that uses Hopcroft's algorithm.

When comparing the compilation times for OpenFst, we see that the
Finnish morphology compiles faster but the German one slightly slower
on HFST version 3.0 than on version 2.0. This is because there are two
factors that contribute to the difference in performance. Firstly, we
are currently using OpenFst version 1.2.7 that is faster than the
previous versions. Secondly, in HFST version 3.0 we no longer use the
same number-to-symbol encodings for all transducers during the same
session. Every time we perform a binary operation on two transducers,
we must harmonize the encodings of the transducers. Nevertheless, 
it seems that the newer, more efficient version of
OpenFst compensates well for this slowness caused by harmonization. 

We did not have the foma implementation available in HFST version 2.0,
but it is evident that it is much faster than the other
implementations in either version of HFST. Foma does not either use
the same symbol-to-number encodings in its transducers, but it still
performs well. It is presumable that symbol harmonization is not a big
factor in the compilation times of morphologies. 


\section{Application Areas}
% TP

\section{Optimized Lookup}\label{optimized-lookup}
% SH

\section{Discussion}
%KL

\section{Conclusion}
% KL

%
%
%
% ---- Bibliography ----
%
\begin{thebibliography}{}
% An example from the demo:
%\bibitem[1980]{2clar:eke}
%Clarke, F., Ekeland, I.:
%Nonlinear oscillations and
%boundary-value problems for Hamiltonian systems.
%Arch. Rat. Mech. Anal. 78, 315--333 (1982)

\end{thebibliography}
\end{document}
