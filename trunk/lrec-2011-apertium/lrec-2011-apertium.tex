\documentclass[11pt,a4paper]{article}
\usepackage{times}
\usepackage{url}
\usepackage{latexsym}
\usepackage{xltxtra}

%\setlength\titlebox{6.5cm}    % You can expand the title box if you
% really have to

\title{Compiling and using Apertium morphological dictionaries with HFST}

\author{Tommi A Pirinen\\
  University of Helsinki\\
  Helsinki, Finland\\
  \url{tommi.pirinen@helsinki.fi}
}

\date{\today}

\begin{document}
\maketitle
\begin{abstract}
    In this paper we present a generic FSA compiler for xml-based morphological
dictionaries used in the machine translation system Apertium and evaluate uses
of the dictionary as parts of other systems. We use a generic finite-state
algebra to provide compilation formula for Apertium's morphological format
and relate it to other languages for describing morphological dictionaries.
We test the quality and speed of using these compiled FSA instead of Apertium's
native ones. We also show how to integrate these dictionaries automatically into
FSA based spell-checking system.
\end{abstract}

\section{Introduction}

Finite-state automata are one of the most effective format for presenting
natural language morphologies in computational format. The finite-state
automata, once compiled and optimised via process of minimisation are very
effective for parsing running text. This format is also used when running
morphological dictionaries in machine-translation system
Apertium~\cite{Apertium/2011}\footnote{}. In this paper we use a slightly
different compilation approach to compile the dictionaries into weighted
two-tape finite-state automata and optimise them for corpus processing using
modified version of compacting described in~\cite{silfverberg/2009/fsmnlp}. We
implement this system using a free/libre open source finite-state API
HFST~\cite{hfst/2011}\footnote{}. HFST is general purpose programming interface
utilising a selection of freely available finite-state libraries for handling
of finite-state automata. There are existing tools in HFST application suite
for compiling other formats of natural language dictionaries into finite-state
automata, including xerox finite-state morphology formalism, which is already
used in part of Apertium's translation systems. In this paper we research
closer the effects of using HFST as Apertium's automata processor with
comparison to actual Apertium finite-state automata.

The HFST is also supported by spell-checking software voikko, which has
bindings for all major spell-checking systems, such as
LibreOffice\footnote{\url{}}, Firefox\footnote{\url{}},
enchant\footnote{\url{}} (used mainly by text widgets in Gnome and GTK+
software), and OS X SpellService. In this article we present an automatic
compilation of Apertium dictionaries into spell checking finite-state automata
and test their performance on running text.

As methodological advance we present a plain finite-state algebra version of
morphotactic combinatorics used in Apertium dictionaries. We contrast this to
other finite-state morphology compilation formulae like Xerox lexc compilation
demonstrated in~\cite{pirinen/2009/sfcm} and hunspell in~\cite{pirinen/2010/cla}.
The use of these compilation methods should also prove that optimisation methods
which apply for morphologies compiled from other formalisms. 
% such as~\cite{pirinen/2013}.

\section{Materials}

The Apertium project hosts a large number of morphological dictionaries for
each of the languages translated. 

The morphological dictionaries are in an XML format specific for Apertium
project, detailed in Apertium manual\footnote{\url{}}. The format describes
morpholotactics basically as lists of morphs that are concatenated: affix
morphs and roots. 

\section{Methods}

The compilation of Apertium dictionaries is relatively straight-forward. We
assume here standard notations for finite-state algebra. There is a set of root
morphs $S_r$in root lexicon and set of affix morphs $S_a$ in pardefs lexicons,
each can be associated with a paradigm reference pointing to a subset of
affixes $S_p \subset S_a$, where $p$ is a name of paradigm defining the set
from set of paradigms $P_s$ Each morph can then be compiled into single-path
finite-state automaton\footnote{the full formula allows any finite-state
language as morph, compiled from regular expressions, the extension to this is
trivial but for readability we present the formula for string morphs}, the
actual morph as string of UTF-8 arcs $m$ extended from both sides by joiner
markers\footnote{ using terminology of \cite{pirinen/2009/sfcm}} $J_p$, where $p
\in S_p$ refers to the paradigm name: $J_{p_l} m J_{p_r}$. The sets of roots
and affixes can be compiled into disjunction of such joiner delimited morphs.
Now, the morphotactics can be defined as related to joiners by any such path
that contains joiners only as pairs of adjacent identical paradigm references:
$\Sigma \cup J_x J_x$, where x is any paradigm name. Now the final dictionary is
simply composition of these morphotactical rules over the concatenation of
affixes and roots: $(M_{a}^{\star} M_{r} M_{a}^{\star} \circ (\Sigma
\cup J_x J_x)^{\star}$, where $M_{a}$ is the disjunction of affixes with
joiners and $M_{r}$ the disjunction of roots.  This formula is mainly a
simplification of the one presented for hunspell in~\cite{pirinen/2010/cla}.

\section{Test Setting and Evaluation}

To verify that the compilation works correctly we need to confirm that the
resulting system can analyse and produce the same strings as original. For
this, we perform two tests: one analysing running text and one generating all
strings the dictionary can understand (excepting cases that may produce
infinite amount, such as regular expression morps), and analysing those. The
recall of our system is calculated as $\frac{\mathrm{correct
results}}{\mathrm{expected results}}$.

To test the efficiency we perform three tests: we compare the average times for
analysing a big corpus with the final automata, we compare the sizes and
features of the resulting automata, and we compare the average times for
compilation of the dictionaries into automata.

Finally we evaluate the usability of dictionaries meant for machine translation
as spell-checkers by running the finite-state spell checkers we produced
automatically through a large corpus and show the measure both speed and
quality of the results.

%\section*{Acknowledgements}


\bibliographystyle{unsrt}
\bibliography{lrec2011}


\end{document}
