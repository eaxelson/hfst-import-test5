% This is the Authors' notes demonstration file with content stripped out
% and sections from Krister's email substituted.
% 
% It might be a good idea to verify that Authors' Instructions.pdf
% (in this directory) is adhered to before submitting.
%
% llncs.doc is actually a tex file, it's the source for the Authors'
% Instructions. There are good examples of eg. tables and graphs there.
\documentclass{llncs}
\usepackage{llncsdoc}
\usepackage{multirow}
\usepackage{caption}
%
\begin{document}
%
\title{HFST - Framework for Compiling and Applying Morphologies}
%
\author{Author Names\inst{}}

\institute{University of Helsinki}

\maketitle

% Removed the manual bibstyle in favor of splncs03.bst,
% if it's required fetch it from svn history

%
\begin{abstract}
% KL
\keywords{finite-state morphology}
\end{abstract}

\section*{Introduction}
% KL


\section{Structural Layout}
% MS


\section{Structural Layout cont.}
% SH
% Comment to remove before submission:
% the relatively insignificant material here should really be incorporated into
% another section..
There has been considerable progress in achieving HSFT's goal of acting as a
compatibility layer between different representations of finite-state
transducers and, more importantly, the operations and formalisms (eg.
\verb+lexc/twolc+, \verb+xfst+, \verb+sfst+) that have been implemented
for them. HFST is now independent of any particular library and requires no
custom extensions to the libraries it uses.

\subsection{Dynamic Linking to Underlying Libraries}
Previously HFST relied on custom extensions to the libraries it supported,
namely OpenFst and SFST, and it was necessary to statically link them into
\verb+libhfst+. This was obviously also rather restrictive in terms of
new versions and different use cases (eg. experimentation with local changes to
the underlying libraries.

HFST3 supports conditional compilation of all its elements that provide
interfaces to underlying libraries, and dynamic linking is done to whichever
libraries the user configures HFST3 to use.

\subsection{Stand-alone Use and Flexibility}
Due to these improvements, HFST3 can also be built without any external
libraries (in which case only the operations for a simple internal
representation and optimized-lookup (see section \ref{optimized-lookup}),
building from text representation and fast lookup will be supported) or only
the user's self-made library, which will then support compilation to
optimized-lookup format.

\section{Coding Principles}
% EA

Exceptional situations occur sometimes in computer programs when the
user does something wrong or there is a bug in the code.
Possible user-originating situations in a finite-state library could
be for example:

\begin{enumerate} 
\item The user tries to read a binary transducer from a
file that contains a text document or does not exist.
\item A transducer in AT \& T text format has a typo on one line and the 
line cannot be parsed. 
\item The user calls a function without checking the preconditions,
e.g. tries to extract all paths from a cyclic transducer.
\end{enumerate}

Throwing an exception on such occasions gives the user a possibility
to catch the exception and recover from the situation. In HFST version
2.0, exceptional situations were handled by printing to standard error
a short message and exiting with an error code. In HFST version 3, 
exceptions are classes that have a figurative name and can contain an 
error message.

For the above scenarios, HFST will throw the following exceptions:

\begin{enumerate} 
\item NotTransducerStreamException or StreamCannotBeReadException and
the name of the file or stream in the error message.
\item NotValidAttFormatException and the line that could not be parsed
in the error message.
\item TransducerIsCyclicException.
\end{enumerate} 

The user could react to the exceptions in the following ways, for
example:

\begin{enumerate} 
\item Check that the file exists and contains transducers and try again
with the correct file.
\item Fix the typo in the text format.
\item Call another function that limits the number of paths extracted
from the transducer.
\end{enumerate} 

Exceptions are also used internally in HFST code for reporting to the 
calling function that something unexpected happened. The calling
function can handle the situation or inform the user of it. 
So the execution of the program does not need to stop or lead to an
erroneous result or even cause later a segmentation fault.

An HfstFatalException is thrown when it is supposed that the user
cannot handle that exception. The user should instead report the error
to the developers of HFST and in which circumstances it happened, because that
is essentially a bug that must be fixed. Sometimes asserts are also
used for internal checks. When an assertion fails the user should similarly
report the assert message and from which file and which line it happened.


\section{Data Format}
% EA

\subsection{Transducer binary format}

An HFST transducer in binary format consists of an HFST header followed by the
backend implementation in binary format. In version 3.0, the header
format is less error-prone than in the previous version and gives more 
information both for users of HFST (even when seen on a screen or in a
text editor in binary format) and for the HFST library itself.
 
The current header format is somewhat similar to foma where pieces of 
information are separated by newline characters to make them more
readable. In HFST version 2, we represented the properties of a
transducer in a cryptic two-byte bit vector akin to OpenFst's header
format. The type of the transducer and the existence of an optional
alphabet were also encoded with two characters in the beginning of the
binary transducer and they were impossible to interpret without
looking at the HFST code itself.

The beginning of an HFST version 3.0 header contains an identifier
'HFST', a separating zero byte, two bytes signifying the length of
the rest of the header in bytes and a separating zero byte. The rest
of the header contains pairs of attributes and their values. The pairs
are separated by newlines and attributes and values by zero bytes. 
HFST version 3.0 header must contain at least the attributes
'version', 'type' and 'name' (in that order) and their values. 
Additional attributes can follow after these obligatory ones. 
For instance, we could include information on the minimality or
cyclicity of a transducer even if the backend implementation did not
store these properties in its binary format (e.g. SFST). 
For more information on the header format, see (ref. to HfstTransducerHeader).

The new header format makes it easier to react to unexpected
situations and inform the user of them. When we start to read an HFST
binary transducer, we first see whether the identifier 'HFST' is
found. If it is not found, we know that the user has given a wrong
type of file and can throw a appropriate exception. 
Next we see what kind of transducer is coming from the stream. 
If the backend transducer library is not linked to HFST, we can handle
the situation by throwing an exception again. 
Next we see the HFST version used and know how to process the header
and the backend implementation correctly. 
If the user has requested a verbose mode for a tool that reads the
transducer, it is possible to print the name of each transducer 
before or after reading it.

\subsection{Conversion between different backend formats}

In HFST version 3.0, the conversion between different backend formats 
(SFST, foma, OpenFst with tropical and logarithmic semiring) is
carried out through HFST's own transducer format, HfstTransitionGraph, 
a simple transition graph datatype that consists of states (unsigned
integers) and transitions between those states.
 
We have chosen to implement HfstTransitionGraph for two
reasons. Firstly, it serves as an intermediate transducer format in
conversions, thus reducing the number of conversion functions from 2 x
N to N x (N - 1), where N is the number of different transducer
backend formats. Secondly, it is easy to implement functions for 
HfstTransitionGraph that allow the user to construct transducers from 
scratch and iterate through their states and transitions. Implementing
such features for some transducer libraries (e.g. SFST and foma) can
be difficult because they are designed to be used on a higher level of 
abstraction. Accordingly, the functions that operate on states and 
transitions are often declared protected and not necessarily well
documented.

HfstTransitionGraph is a class template with template parameters T and
W. T defines the type of transition data that a transition uses and W
the weight type that is used in transitions and final states. 
HfstTransitionGraph contains two maps. One maps each state to a set of
that state's transitions (that are of type class HfstTransition\textless class
T\textgreater). The other maps each final state to its final weight 
(that is of type class W). Class T must use the weight type W. 
A state's transition (class HfstTransition\textless class T\textgreater) 
contains a target state and a transition data field (that is of type class T).

Actually, HfstTransitionGraph is not a transducer but a more
generalized transition graph that can contain many kinds of data in
its transitions. Currently, the HFST library offers the specializations 
HfstBasicTransducer and HfstBasicTransition for HfstTransitionGraph
and HfstTransition. These specializations are designed for weighted 
transducers. The weight class W is a float and the transition data
class T contains an input string, an output string and a weight of
type float. The specializations HfstBasicTransducer and
HfstBasicTransition are used when converting between different
transducer backend formats.

The class template HfstTransitionGraph is designed so that it can
easily be extended for different kinds of transition datatypes. For
example, if HFST tools are used in text-to-speech or speech-to-text
conversion, the symbol type of transitions will probably be something
else than strings.



\section{Alphabet}
% EA

The alphabet of a transducer means all symbols (strings) that are
known to that transducer. The alphabet includes all symbols that occur 
or have occurred in a transition of the transducer unless explicitly
removed from the alphabet. 
If we apply a binary operation (e.g. disjunction or composition) on 
transducers A and B, the resulting transducer's alphabet will include
all symbols that were in the alphabets of A and B. 

In HFST version 2.0, we were not especially interested in alphabets 
since the interface did not offer any way for the user to access a 
transducer's alphabet. It was up to the backend implementation to take
care of alphabets. In SFST the transducers always have an alphabet,
but in OpenFst their use is optional so we did not use them in our
OpenFst implementation.

In HFST version 3.0, we need to be aware of alphabets because two new
special symbols are included, UNKNOWN and IDENTITY. These special
symbols are a part of the Xerox Finite-State Tool (XFST) 
formalism~\cite[page x]{beesley/2003} and they are also implemented in
foma~\cite{hulden/2009}. UNKNOWN and IDENTITY symbols are useful
when we want to refer to all symbols that are not currently known to a
transducer but which the transducer can later become aware of. 

Supporting UNKNOWN and IDENTITY symbols in all HFST backend
implementations has enabled us to make an XFST compiler that can be used
with all backend implementations. 
In this way we can offer the users of HFST new regular expression
formalism in addition to the SFST programming language. Next we
describe what these new special symbols require for HFST's
part. Because they are already implemented in foma, we have to care
only for the SFST and OpenFst implementations.

Besides keeping track of all symbols known to a transducer, we also
have to expand each transition involving UNKNOWN and IDENTITY symbols
into a set of transitions every time we apply a binary operation on
two transducers. 
This is because the transducer becomes aware of new symbols that are
no longer unknown and thus no more included in UNKNOWN or IDENTITY
symbols.
Fortunately, this expansion can be done before the operation itself 
(and for composition before and after the operation itself), so we do
not have to make changes in the operations of the backend transducer
libraries. 
The operations can freely (and will) handle these special symbols just
like any ordinary symbols. 

First we iterate through the alphabets of both transducers and find
out what symbols in the alphabet of one transducer are not found in
the alphabet of the other transducer and vice versa. 
Then we add beside each transition involving UNKNOWN or IDENTITY
symbols a set of transitions where UNKNOWN and IDENTITY symbols are
replaced with all symbols that the transducer just got aware of. 
For more information on expanding special symbols, 
see~\cite{hulden/2009}~and~\cite{beesley/2003}.

It is also possible to switch off special symbol handling if we know
for sure that they are not used in transducers. 
In this way we can optimize performance for instance for the tool 
hfst-calculate that processes SFST programming language which does not
support unknown or identity symbols.


\section{Algorithmic Improvements}
% MS

\section{Xerox Compatibility}
% TP

Among the one goals of HFST framework has always been to retain legacy support
for Xerox line of tools for building finite-state
morphologies~\cite{beesley/2003}. The support should also be trivial for
end-users converting from the Xerox tools. For this purpose we have aimed to
create clones of the most important Xerox tools as accurate as possible.
Previous open source implementations of Xerox tool clones have included the
lexc and twolc~\cite{linden/2009/sfcm} and lexc and xfst~\cite{hulden/2009}, in
HFST 3 we have combined these contributions to one uniform package capable of
handling full line of Xerox tools for morphology, which for most intents and
purposes means that end users will require no other work than changing program
names to start using HFST tools for their Xerox-style language description.

For specific functionality, the Xerox tools have lots of specific special
processing of finite-state automata, that is not part of standard finite-state
algorithms. Primary example of this is handling of special symbols such as
flag diacritics~\cite{beesley/1998}, which would require support from underlying
libraries for many finite-state operations to work as they do in Xerox tools
when using \texttt{flag-is-epsilon} and \texttt{obey-flags} settings. In
HFST tools we have provided support for same options and provided fall-back
processing where it is possible to have backend libraries support required
operations. 

\section{Compilation Performance}
% EA

The performance of HFST has improved from version 2.0 to 3.0. 
We compiled two finite-state morphologies in SFST programming language format
with HFST versions 2.0 and 3.0. 
The morphologies were OMorFi (ref.) for Finnish and Morphisto (ref.) for German.
In table~\ref{tab:compilation_times} are the compilation times 
for both morphologies with 
different backend implementations with both versions of HFST. 
Note that the foma implementation was not available in version 2.0.

\begin{table}
\centering
  \begin{tabular}{ c | c | c | c }
  \multicolumn{4}{c}{Compilation times} \\ \hline
  Backend & version & Finnish & German \\ \hline
  \multirow{2}{*}{SFST} & 2.0 & 25:16 & 107:47 \\
  & 3.0 & 5:02 & 6:39 \\ \hline
  \multirow{2}{*}{OpenFst} & 2.0 & 7:54 & 6:23 \\
  & 3.0 & 6:51 & 6:28 \\ \hline
  \multirow{2}{*}{foma} & 2.0 & - & - \\
  & 3.0 & 1:49 & 1:29 \\
  \end{tabular}
  \caption{Compilation times for Finnish and German morphologies with
    HFST. The times are expressed in minutes and seconds.}
  \label{tab:compilation_times}
\end{table}

We can clearly see that the compilation time has improved dramatically
for the SFST implementation.
This is mainly because the new version of SFST, 1.4.2, uses Hopcroft's 
minimization algorithm instead of Brzozowski's. 
We noticed how the minimization algorithm affects performance
already when we were testing HFST version 2.0; 
OpenFst was clearly faster because it uses Hopcroft's algorithm. 
Based on this observation, Helmut Schmid could improve his SFST by 
writing a minimization function that uses Hopcroft's algorithm.

When comparing the compilation times for OpenFst, we see that the
Finnish morphology compiles faster but the German one slightly slower
on HFST version 3.0 than on version 2.0. This is because there are two
factors that contribute to the difference in performance. Firstly, we
are currently using OpenFst version 1.2.7 that is faster than the
previous versions. Secondly, in HFST version 3.0 we no longer use the
same number-to-symbol encodings for all transducers during the same
session. Every time we perform a binary operation on two transducers,
we must harmonize the encodings of the transducers. Nevertheless, 
it seems that the newer, more efficient version of
OpenFst compensates well for this slowness caused by harmonization. 

We did not have the foma implementation available in HFST version 2.0,
but it is evident that it is much faster than the other
implementations in either version of HFST. Foma does not either use
the same symbol-to-number encodings in its transducers, but it still
performs well. It is presumable that symbol harmonization is not a big
factor in the compilation times of morphologies. 


\section{Application Areas}
% TP

After initial release of HFST platform it has been used in several end-product
application software. The two most prominent uses are as a part of rule-based
machine translation platform in apertium\footnote{\url{http://apertium.sf.net}}
and spell-checking library voikko\footnote{\url{http://voikko.sf.net}}.

\subsection{Apertium interoperability---corpus processing tools and I/O formats}

In apertium the finite-state automata are used to provide language models for
both parsing the running text and generating the translations after performing
a mid-shallow rule-based transfer. The HFST is only one possible language
model, so the crucial part for inclusion was to get HFST language models
work as others. This includes two functions: reliable tokenization based on
the dictionary data and support for apertium I/O formats. The total
contribution of this corpus processing functionality is contained in tool
called \texttt{hfst-proc} included in HFST toolkit. The name originates from
the interoperability with other toolkits' corpora processing tools, specifically
\texttt{cg-proc} from vislcg3\footnote{\url{http://visl.sdk.edu.dk}} and
\texttt{lt-proc} from apertium itself.

For tokenization the FST-based dictionaries are useful, since the process of
analysis and lookup can be both performed by basic FST traversal. The specific
implementation of analysis and tokenisation with single FST traversal was
implemented as Google summer of code project, based on previous studies on
topic~\cite{garrido-alenda/2002}. The basic program logic of automata traversal
for longest matches is trivially extended here by processing of flag diacritics
and weights.

The I/O format handling is \ldots

\subsection{Voikko and HFST based spell-checker formulation}

The application of finite-state language models for spell-checking applications
is also based on new development of finite-state algorithms. The application
framework including HFST spell-checkers is voikko library, which provides
spell-checkers for OpenOffice.org/LibreOffice, the GNOME desktop (via
enchant), Mac OS X (via SpellService) and Mozilla application suite.

The finite-state formulation of spell-checking system was developed based on
previous research~\cite{oflazer/1996,agata/2002,pirinen/2010/lrec}. Furthermore
we have optimised the application of error models to language models using
specialised form of parallel composition to apply the filter with standard
composition operation on the fly. 

\section{Optimized Lookup}\label{optimized-lookup}
% SH

\section{Discussion}
%KL

\section{Conclusion}
% KL

%
%
%

\bibliographystyle{splncs03}
\bibliography{sfcm-2011}

\end{document}
% vim: set spell
