\documentclass[11pt]{article}
\usepackage{coling2014}
\usepackage{times}
\usepackage{url}
\usepackage{latexsym}


\title{Hyper-minimization of Finite state Lexicions Using Flag Diacritics}


\author{First Author \\
  Affiliation / Address line 1 \\
  Affiliation / Address line 2 \\
  Affiliation / Address line 3 \\
  {\tt email@domain} \\\And
  Second Author \\
  Affiliation / Address line 1 \\
  Affiliation / Address line 2 \\
  Affiliation / Address line 3 \\
  {\tt email@domain} \\}

\date{}

\begin{document}
\maketitle
\begin{abstract}
  max 200 words
\end{abstract}




\section{Introduction}
%
% The following footnote without marker is needed for the camera-ready
% version of the paper.
% Comment out the instructions (first text) and uncomment the 8 lines
% under "final paper" for your variant of English.
% 
\blfootnote{
    %
    % for review submission
    %
    \hspace{-0.65cm}  % space normally used by the marker
    Place licence statement here for the camera-ready version, see
    Section~\ref{licence} of the instructions for preparing a
    manuscript.
    %
    % % final paper: en-uk version (to license, a licence)
    %
    % \hspace{-0.65cm}  % space normally used by the marker
    % This work is licensed under a Creative Commons 
    % Attribution 4.0 International Licence.
    % Page numbers and proceedings footer are added by
    % the organisers.
    % Licence details:
    % \url{http://creativecommons.org/licenses/by/4.0/}
    % 
    % % final paper: en-us version (to licence, a license)
    %
    % \hspace{-0.65cm}  % space normally used by the marker
    % This work is licenced under a Creative Commons 
    % Attribution 4.0 International License.
    % Page numbers and proceedings footer are added by
    % the organizers.
    % License details:
    % \url{http://creativecommons.org/licenses/by/4.0/}
}

\section{Background}

\label{sec:background}

 
\section{Flag diacritics}
\label{sec:flags}

Flag diacritics are special multi-character symbols which are interpreted during runtime. They can be used to optimize large transducers to couple entrance points of the sub-graphs with the correct exit points.

Their special syntax is: \verb+@operator.feature.value@+, where
\texttt{operator} is one of the available operators (P, U, R, D, N, C), \texttt{feature} is the name of a feature set by the user and \texttt{value} can be any value held in a feature, also provisionally defined. For additional information on the semantics of flag diacritic operators, see~\newcite{beesley2003finite}.


In this paper, we will use only two types of flag diacritics: positive
setting (\verb+@P.feature.value@+) and require test
(\verb+@R.feature.value@+). While positive setting flag only sets the
feature to its value, the require test flag invokes testing whether the
feature is set to the designated value. For example,
\verb+@P.LEXNAME.Root@+ will set feature \texttt{LEXNAME} to value
\texttt{Root}. If later in the path there is an R flag that requires test
\verb+@R.LEXNAME.Root@+, the invoked test will succeed and that path
will be considered valid.



\section{Methods}
\label{sec:methods}

Our algorithm is based on lexc (cite: Tommi) algorithm ...


\subsection{Lexc}

Previous version of lexc took to long to compile because each sub-lexicon was build separately and then disjunct with the rest. Compilation time of large morphologies would take  up to 2 hours. In order to improve compilation speed and incorporate hyper-minimization part, we needed to change the lexc algorithm.

We build a trie, every sublexicon starts from the same start state with the sublexicon name, then morph follows and it ends with the continuation.
In case the morph is a pair of two strings, epsilon padding is added to the end of the shorter string.

Lexc can also contain regular expressions. In that case, the regular expression is parsed and processed into a transducer and saved into a table of regular expression keys and matching transducers. The key is added to the trie same way the strings are - trie entry will start with the encoded sub-lexicon name, followed by regex key and finished with a continuation. LAter in the process, the regex keys are substituted with matching transducers from the hash table.


When the entire lexical file is read into a trie, the trie is transformed into a transducer and over-generated with Kleene star.

$trie -> transducer, overgenerate with repeat\_star()$

Then, to the beginning and end of the transducer are concatenated starting and ending encoded joiners. In case of non-flagged version, the starting joiner is initial lexicon name, usually \texttt{Root} and ending joiner is encoded final lexicon, \texttt{\#}.

In case of the hyper-minimized transducer, the starting joiner is encoded R flag of the initial sub-lexicon, usually \texttt{P.LEXNAME.Root} and the ending one is R flag of the final lexicon, \texttt{R.LEXNAME.\#}.


To filter out invalid flag diacritic paths, tothe transducer is composed this filter:




\begin{equation}\label{filter}
(\verb+P.FLAG R.FLAG+ \cup \Sigma^*)^* 
\end{equation}

without flags:
lexicons = start.concatenate(lexicons).concatenate(end).minimize();
            initialLexName lex \#
\begin{verbatim}
 StringPairVector newVector(tokenizer_.tokenize(joinerEnc + joinerEnc));
            joinersTrie_.disjunct(newVector, 0);
      
            
with flags
          lexicons = startP.
                      concatenate(lexicons).
                      concatenate(endR).
                      minimize();
$ StringPairVector newVector(tokenizer_.tokenize(flagPstring + flagRstring));
            joinersTrie_.disjunct(newVector, 0); $
            
            
            
            
------

\begin{verbatim}
StringPairVector newVector(tokenizer_.tokenize(alph)); <--- all right symbols, a da nije jedan od
                                String prefix1("@@ANOTHER_EPSILON@@");
                                String prefix2("$_LEXC_JOINER.");
                                String prefix3("@_");
                                String prefix4("$P.LEXNAME.");
                                String prefix5("$R.LEXNAME.");
 
   joinersTrie_.disjunct(newVector, 0);


HfstTransducer joinersAll(joinersTrie_, format_);
joinersAll.repeat_star();
joinersAll.minimize();


lexicons.compose(joinersAll).minimize();
\end{verbatim}

----
Joniers -> epsilon
----
Insert regular expressions
----
$lexicons_basic.substitute(regMarkToTr, true);$




\subsection{Adding flag automatic flag diacritics to the lexc compilation}
Similarly as explained in paper ~\cite{drobac2014}. 





In Table~\ref{table:sizes} we show sizes of the original
transducers compiled with the regular lexc compiler composed with grammar rules, transducers compiled
with our new method that inserts flag diacritics composed with grammar rules and finally their ratio.

\begin{table}
    \centering
    \begin{tabular}{|l|r|r|r|}
        \hline
        \bf Language & \bf Original & \bf With flags & \bf \% \\
        \hline\hline
        \bf Greenlandic &   168   & 17 & 10,1\%  \\
        \bf North Saami &   12     & 5,7 & 47,5\%  \\
        \bf Finnish &   17     & 16 & 94,1\%  \\
        \bf Lule Saami  &   5     & 3 & 60,0\%  \\
        \bf Erzya       &   3,7     & 5,3 & 143,2\%  \\
        \hline
    \end{tabular}
    \caption{Sizes of transducers without and with automatic flags (in megabytes); Percentage shows size of the flagged transducer in comparison with the original
    \label{table:sizes}}
\end{table}


\begin{table}[h]
 \centering
    \begin{tabular}{|l|r|r|r|}
        \hline
        \bf Language & \bf Original & \bf With flags & \bf \% \\
        \hline\hline
        \bf Greenlandic & 2 770 w/s & 2 507 w/s & 90,5\%  \\
        \bf North Saami & 30 714 w/s & 8 775 w/s & 28,6\%  \\
        \bf Finnish  & 84 415 w/s & 27 420 w/s & 32,5\%  \\

        \hline
    \end{tabular}
    \caption{Look-up speed of transducers without and with automatic flags; Percentage shows speed of the flagged transducer in comparison with the original
    \label{table:lookup}}
\end{table}


% Find out and discuss why tr with lots of flags get big after applying rules

\section{Data}
\label{sec:data}

We measure the success of our algorithm using real-world, large-scale
language descriptions. For this purpose we have acquired freely
available, open source language descriptions from the language repository of the University of 
Tromsa~\cite{moshagen2013building}.\footnote{https://victorio.uit.no/langtech, revision 73836} The
languages selected are Greenlandic (kal), North Saami (sme), Erzya
(myv), Finnish (fin) and Lule Sami (smj).

All operations with transducers were performed using Helsinki Finite
State Technology tools~\cite{linden2011}.



\section{Discussion}
\label{sec:discussion}



%\subsection{Future Directions}
%\label{subsec:future-directions}

%This is an optimistic thing so we thought that automatic induction of flags
%shoulda work nicely for other neat things too. Hyperminimisation based on
%morphophonology would be cool. Also, graph-structure. And other things.

\section{Conclusion}
\label{sec:conclusion}



\iffalse
\section*{Acknowledgements}
The research leading to these results has received funding from FIN-CLARIN, Langnet and the
European Commission's 7th Framework Program under grant agreement nÂ° 238405 (CLARA).
\fi

\bibliographystyle{acl}
\bibliography{hyperminimization-with-lexc2.bib}




\end{document}
