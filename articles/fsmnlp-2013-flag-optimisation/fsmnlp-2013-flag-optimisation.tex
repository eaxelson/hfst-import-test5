\documentclass[11pt]{article}
\usepackage{acl2013}
\usepackage{url}
\usepackage{latexsym}

\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}

\setmainfont[Mapping=tex-text]{Times New Roman}

%\setlength\titlebox{6.5cm}    % You can expand the title box if you
% really have to

\title{Optimising Morphological Analyser Automata Using Morphological Structure
and Automatically Induced Flag Diacritics}

\iffalse
\author{Senka Drobac \\
Department of Modern Languages \\
PO Box 24 \\
00014 University of Helsinki \\
  {\tt senka.drobac@helsinki.fi} \\\And
  Tommi A Pirinen \\
Departmet of Speech Sciences\\
PO Box 9\\
00014 University of Helsinki\\
  {\tt tommi.pirinen@helsinki.fi} \\}\\\And
  Miikka Silfverberg \\
  Department of Modern Languages \\
	PO Box 24 \\
	00014 University of Helsinki \\
	{\tt miikka.silfverberg@helsinki.fi} \\}
\fi

\date{\today}

\begin{document}
\maketitle
\begin{abstract}
    Flag diacritics are a historical method of optimising finite-state networks
    by combining identical structures with differing parts. Traditionally the
    feature has required linguists to write the optimisation of the graph by
    hand alongside morphological descriptions. In this paper we present a novel
    method of discovering ideal flag positions automatically based on the
    morpheme strucuture implicit in the language description. With this
    approach we have gained significant decrease in size of finite-state networks
    without drastic speed penalties on the application phase.
\end{abstract}

\section{Introduction}

The finite-state automata are optimal way of encoding morphological analysers
of natural languages. The automata made for large-scale language materials can
often grow to be too large for some use cases. These automata can be optimised
by recognising equivalent sub-graphs in the automaton, and combining them using
special symbols called flag diacritics to determine the correct entrance and
exit paths. Typical way of applying flag diacritics now requires a linguist to
provide the compiler with the positions for these flags. However, there are two
major problems with this kind of approach: firstly linguists are not very good
in knowing the structure of finite-state networks that will become from
lexicographical-morphological descriptions, secondly the addition of flag
diacritics to these descriptions makes them unreadable and unmanageable since
the amount of non-linguistic data in the linguistic description increases. This
article seeks to address the problem using an algorithm for inducing the ideal
flag positions from the linguistic morpheme structure of the analyser that is
implicitly present in the description. 

One of the reasons why flag diacritics have been so cumbersome in the past,
is their two-fold nature. On the other hand they are there to optimise the
finite-state automaton structure, e.g. in~\cite{karttunen2006numbers}, on the
other hand they are the primary method of describing non-contiguous 
morphological constraints~\cite{beesley1998constraining}. If they are applied
on the constriction of separated morphotactic dependencies, the effect on
optimisation is at best haphazard, and the resulting description does not
look very linguistically motivated or maintainable as computational description.

The paper is organised as follows: In the section~\ref{sec:background} we
introduce the flag diacritics and optimisation problems of finite-state 
automata. In the section~\ref{sec:methods} we show the algorithm for automatic
flag induction we use and describe how was achieved flag harmonization in compose function. 
In section~\ref{sec:data} we briefly go through the existing language
descriptions we use for testing. In 
section~\ref{sec:evaluation} we show the effects of applying our algorithm
to the size and efficiency of the finite-state automata. In~\ref{sec:discussion}
we evaluate the pros and cons of our approach and lay out future improvements,
and finally in section~\ref{sec:conclusion} we tie the article together by
verifying what we set out to study.

\section{Background}
\label{sec:background}

Finite state morphology~\cite{beesley2003finite} is the state-of-the-art in
writing morphological analysers for natural languages of the whole range of
typologically varying morphological features. The practical finite-state
approach in this frame is build around two practical concepts: writing
lexicographical descriptions of the language using a syntax called lexc, and
writing morphophonological variations in regular expression rules. In this
paper we study the use of lexicographical structure as framed by lexc. Lexc
itself is a simple right-linear phrase structure grammar formalism. In
linguistic terms this means approxiamtely the following: we have concept of
lexicon, which refers to set of morphemes. Each of these morphemes defines a
continuation, which determines a set of morphemes that can come after it. And
these are the only two things there are. 

If think of Finnish morphology for example, nominal inflection is built neatly
from left to right with morphemes. In figure~\ref{fig:lexc-fin} there is a 
lexc representation of Finnish words \emph{talo} `house' and \emph{asu}
`clothing' and \emph{kärry}, and nominal suffixes \emph{n} (singular genitive),
\emph{lle} (singular allative) and \emph{ksi} (singular translative). The
structure of the grammar starts from the \texttt{Root}, each of the nouns in
root set of morphemes continues rightwards to \texttt{NOUNCASES} set of 
morphemes, and each case morpheme continues towards the special \texttt{\#}
lexicon signifying the end of a word-form.

\begin{figure}
    \centering
    \begin{verbatim}
    LEXICON Root
    talo NOUNCASES ;
    asu NOUNCASES ;
    kärry NOUNCASES ;

    LEXICON NOUNCASES
    n # ;
    lle # ;
    ksi # ;
    \end{verbatim}
    \caption{Simplified part of Finnish lexc grammar description
    \label{fig:lexc-fin}}
\end{figure}

Finnish was used as an example in Karttunen's paper on flag diacritics in
optimisation~\shortcite{karttunen2006numbers}. In this paper, he showed that
the optimisation quality of wisely selected flag diacritics is significant;
from 20,498 state automaton to 1,946 state one. The article describes Finnish
numerals, which have the feature of requiring agreeing inflection in free
compounding, and this can be achieved by allowing all compounds and restricting
the combinations by flags instead of lexicon structure. Article does not
unfortunately show examples or re-producable description of the lexicographical
data, but to our experience there are no available morphologies that show
similar compression quality, so it can be considered towards the upper bounds
of what such compression can achieve.
 

\section{Methods}
\label{sec:methods}

Flag diacritics are special multi-character symbols which are interpreted during runtime. They have special syntax: \verb+@operator.feature.value@+, where operator is one of the available operators (P, U, R, D, N, C), feature is name of a feature provisionally set by user and value can be any value held in feature, also provisionally defined ~\cite{beesley2003finite}.

In this paper, we will use only two types of flag diacritics: positive setting (\verb+@P.feature value@+) and require test (\verb+@R.feature value@+). While positive setting flag only sets the feature to its value, require test flag invokes testing if the feature is set to the designated value.
For example, \verb+@P.LEXNAME.Root@+ will set feature \texttt{LEXNAME} to value \texttt{Root}. If later in the path occurs request test flag \verb+@R.LEXNAME.Root@+, the invoked test will succeed and that path will be considered as valid. 

Our algorithm is based on the finding that adjacent morph combinatorics can be expressed with finite-state flags like this:

Every rightward continuation is replaced with positive setting flag with feature called \texttt{LEXNAME} and value corresponding to the continuation lexicon. For example, lexicon in figure~\ref{fig:lexc-fin} has two rightward continuations: \texttt{NOUNCASES} and \texttt{\#}, which are presented with flags \verb+@P.LEXNAME.NOUNCASES@+ and \verb+@P.LEXNAME.#@+. 
The same way, every leftward continuation is replaced with request test flag, also with feature \texttt{LEXNAME} and corresponding value. Therefore, lexicon shown in figure~\ref{fig:lexc-fin} will have also two leftward continuations: \texttt{NOUNCASES} and \texttt{\#}, which are this time presented with flags \verb+@R.LEXNAME.NOUNCASES@+ and \verb+@R.LEXNAME.#@+. Additionally, every lexicon starts with \texttt{Root}, which is represented with pair of flags \verb+@R.LEXNAME.Root@@R.LEXNAME.#@+.

The transducer built from lexicon in figure~\ref{fig:lexc-fin} is shown in figure~\ref{fig:lexc-fin-flag}. 


Lexicons that contain flag diacritics can be composed to other
transducers without worrying about flag collision or flag diacritics
being part of the contexts (in i.e. replace rules). This is achieved
by renaming flag diacritics in both argument transducers in such a way
that collisions become impossible and then inserting flag diacritics
freely from each argument to the other.

Consider for example composition of a lexicon $L$ with a rule $R$. If
both transducers contain flag diacritics for feature {\tt FEATURE},
the feature is renamed {\tt FEATURE1} in $L$ and {\tt FEATURE2} in
$R$. All flag diacritics (like {\tt @P.FEATURE.True@}) are renamed
correspondingly (to {\tt P.FEATURE1.True@} in $L$ and {\tt
  P.FEATURE2.True@} in $R$) and a new lexicon $L'$ and rule $R'$ are created
by inserting freely all flag diacritics with feature {\tt FEATURE1}
into $R$ and flag diacritics with feature {\tt FEATURE2} into the
lexicon $L$.

The transducers $L'$ and $R'$ can be composed and it is easy to
see that the result satisfies the property that, if flag diacritics
are compiled out, then the resulting transducer without flag
diacritics will accept exactly the same strings as the composition of
the transducers that are obtained by compiling out flag diacritics
from the original lexicon $L$ and the original rule $R$.


\begin{figure*}
    \includegraphics[width=\textwidth]{transducer.png}
     \caption{Simplified part of Finnish lexc grammar description with automatic flags
     \label{fig:lexc-fin-flag}}
\end{figure*}

\section{Data}
\label{sec:data}

We measure the success of our algorithm using real-world, large scale language
descriptions. For this purpose we have acquired freely available, open source
language descriptions from University of Tromsa's language 
repository~\cite{moshagen2013building}. The languages selected are Greenlandic (kal), 
North Saami (sme), Erzya (myv), Komi Zyryen (kpv), South Sami (sma), Lule Sami (smj) and German (deu).

Speed performances of North Saami and Erzya were tested by performing lookup on Wikipedia texts, while Greenlandic and Lule Saami had texts available
 in the Tromsa's language repository.
 
 All the operations with transducers have been done using Helsinki Finite State Technologies~\cite{linden2011}.



\section{Evaluation}
\label{sec:evaluation}

To evaluate the algorithm, we measure the proportional size gains that are
achieved by the flags we introduce as compared to the equivalent automaton
without the induced flags. Since introduction of flags always causes an overhead in the
application time of the automata, we also measure the average running speed
of the automata with our flags to get the trade-off ratios.

In table~\ref{table:sizes} there are shown sizes of the original transducers compiled with regular lexc compiler, transducers compiled with new method that inserts flag diacritics and finally their ratio.

\begin{table}
    \centering
    \begin{tabular}{|l|r|r|r|}
        \hline
        \bf Language & \bf Original & \bf With flags & \bf \% \\
        \hline
        \bf Greenlandic &	261074412 	& 8400635 & 3,4\%  \\
        \bf North Saami &	9152930 	& 6789658 & 74\%  \\
        \bf Erzya		&	3333669 	& 2801339 & 84\%  \\
        \bf Komi Zyryen &	2719971 	& 2315384 & 85\%  \\
        \bf South Saami &	3600902 	& 3147213 & 87\%  \\
        \bf Lule Saami 	&	4381573 	& 3639278 & 87\%  \\
        \bf German 		&	25836 		& 32678   & 126\%  \\
        \hline
    \end{tabular}
    \caption{Sizes of transducers without and with automatic flags (in bytes); Percentage shows size of the flagged transducer in comparison to the original
    \label{table:sizes}}
\end{table}

In table~\ref{table:speed} there are speed measures of optimized lookup performed on Wikipedia texts. Before measurements, transducers were transformed to the HFST's optimized lookup format and the test was done with hfst-lookup tool. In the first column there are results when lookup was done with original transducer and the second colum shows results with automatically flagged one. 

\begin{table}
    \centering
    \begin{tabular}{|l|r|r|}
        \hline
        \bf Language & \bf Original & \bf With flags \\
        \hline
        \bf Greenlandic & 58832 & 4663\\
        \bf North Saami & 228347  & 1141 \\
        \bf Erzya & 111394  & 3010\\
        \bf Lule Saami & 1 21262 & 4352 \\
        \hline
    \end{tabular}
    \caption{Sizes of automata with and with-out flags (in words per second)
    \label{table:speed}}
\end{table}


\begin{figure*}
    \includegraphics[width=\textwidth]{gr.png}
     \caption{Simplified part of Greenlandic lexc grammar description with automatic flags
     \label{fig:lexc-gr-flag}}
\end{figure*}

\section{Discussion}
\label{sec:discussion}

The results of this study show that large scale language descriptions compile into smaller transducers when flags were inserted automatically. This is especially true for language descriptions which repeat morphemes in many different places, like in Greenlandic. Since flag diacritics themselves take space in the transducer graph, this method showed not to be appropriate for smaller languages.

Working with real-world languages, we have noticed that in practice language descriptions often contain empty, or nearly empty, continuation lexicons. Inserting flags in those cases only increases size of the transducer, without gaining any benefits. Therefore, those continuation lexicons should be recognized during compilation time and skipped when inserting corresponding flag diacritics.

While R flag diacritics will always occur only once for every left continuation lexicon, the results have shown that, for certain right continuations, P flag diacritics occur hundreds of times. This will happen every time when in the same set of morphemes there are words which have the same beginning. For example, in figure~\ref{fig:lexc-gr-flag} there is shown how two morphemes \texttt{maagar} and \texttt{maagarnar} have same continuation flag \verb+@P.LEXNAME.IV@+, but they can't collapse into the same path. It should be checked if skipping inserting flags for those paths would further reduce size of transition graphs.



%Surprisingly, no differences were found in ......
%There are several possible explanations for this result.

%\subsection{Future Directions}
%\label{subsec:future-directions}

%This is an optimistic thing so we thought that automatic induction of flags
%shoulda work nicely for other neat things too. Hyperminimisation based on
%morphophonology would be cool. Also, graph-structure. And other things.

\section{Conclusion}
\label{sec:conclusion}

In this article we showed that by using morphologically motivated flags we can
improve the size of the large transducers while still keeping the processing speeds in reasonable range. 
Automatically inserted flag diacritics would make manual optimization preformed by linguists unnecessary, which would result in  
more readable and easier to maintain linguistic descriptions.
\iffalse
\section*{Acknowledgments}
The research leading to these results has received funding from the European Commission’s 7th Framework Program under grant agreement n°238405 (CLARA).
\fi

\bibliographystyle{acl}
\bibliography{fsmnlp2013flags}




\end{document}
